#' This function will generate a plot for each chem_id in the HTPP dataset (for each cell type if applicable).  Creates a plot of cell viability data for each chemical id in the dataset in the location specfied by filepath.
#'
#' @param file_path character string: path to directory where HTPP plots will be populated
#' @param study_name character string: name of study to be used for plot titles
#' @param mongoUrl character string: the database where the collections are be stored and the required credentials, generated by the mongoURL function
#' @param refChems boolean: only make viability plots for reference chemicals instead of all chemicals; default in TRUE
#' @param use_db boolean: Determines whether mongoDB will be used or not; default is TRUE
#' @param json_collection_path character: Full file path to where JSON collections will be stored
#'
#' @import data.table
#' @import plyr
#' @import dplyr
#' @import tidyr
#' @import jsonlite
#' @import mongolite
#' @import stringr
#' @import tictoc
#' @import tibble
#'
#'
#' @export cellViability_plots
#'
cellViability_plots <-function(file_path, study_name, mongoUrl="", refChems = TRUE, use_db=T, json_collection_path=""){

  # 1. Generate cv curve plots

 if(use_db==T){cv_tcpl <- data.table(mongo(collection="cv_tcpl", url=mongoUrl, verbose=getOption("verbose"))$find())
  if (length(cv_tcpl)<1){
    stop("cv_tcpl collection is empty")
  }
 } else{
   if(file.exists(paste(json_collection_path,"cv_tcpl.JSON",sep="/"))){
     cv_tcpl <-data.table(fromJSON(txt=paste(json_collection_path,"cv_tcpl.JSON",sep="/")))
     cv_tcpl[cv_tcpl == "NA"] <- NA
   } else {
     stop("cv_tcpl.JSON not found, check json_collection_path parameter.")
   }
}

  for(cell in unique(cv_tcpl[, cell_type])){


    PlotOptions <- tibble(endpoint = c("rel_cell_count"),
                          Assay = c("cell count"), #assay names to adjust some parameters in the function
                          Cell_Type = cell,
                          Color = adjustcolor(c("gray30"), alpha.f=0.9),
                          Lwd = c(2),
                          Lty = c("solid"),
                          Pch = c(15),
                          PchCex = c(2))

    Data <- cv_tcpl[cell_type == cell, ] %>% dplyr::left_join(PlotOptions) %>% dplyr::mutate(BMC = bmd)

    if(refChems == TRUE){
      Data <- Data[stype == "reference chemical" | stype == "viability positive control",]
    }

    ChemList <- Data[cell_type == cell, ] %>% select(chem_id) %>% distinct() %>% arrange(chem_id)
    CellList <-  Data[cell_type == cell, ] %>% select(cell_type) %>% distinct() %>% arrange(cell_type)

    for(Chem in ChemList$chem_id){
      print(paste("***************", Chem, "**********************"))
      Subset1 <- as.data.frame(Data) %>% filter(chem_id == Chem)

      png(paste0(file_path, "/", study_name, "_", cell, "_", Chem, "_cvPlot.png"), width=4*5, height=2*5, units="in", res=200)
      #layout(matrix(c(9,9,9,9, 1:8), 3, 4, byrow = T), heights=c(0.2, 1, 1))

      #for(CellType in CellList$cell_type){

      # Subset2 = Subset1 %>% filter(cell_type == CellType)
      #
      # par(mar=c(4.5,5.2,2,5.2))  #vector of the form c(bottom, left, top, right)
      #
      plotCurves(Subset1,
                 yLim = c(0, 150), yAxisSteps=25,
                 plotDatapoints=T, plotBMC=T, plotDoserange=F, plotNoiseband=T,
                 cexAxis=1.25, Lwd = 2)


      # mtext(side = 1, paste(Chem, " [?M]"), cex=1, font=2, line = 2.5)
      #
      # mtext(side = 2, "response [%]",       cex=1, font=2, line = 3.5, col="black")
      #
      # mtext(side = 3, CellType,  cex=1.5, font=2, line = -2)

      # }#for each compound #there is no cell type in this study

      #print the title
      #plot.new()
      par(mar=c(0,0,2,0))  #vector of the form c(bottom, left, top, right)
      mtext(side = 1, paste(Chem), cex=2, font=2, line = -1)

      dev.off()

    }#for each chem

  }#for each cell type

}

#' Create plots from htpp_well and write them to the location specified in file_path
#'
#' @param file_path character string: The path to where the plots will go.
#' @param vehicle_control character string: chem_id for vehicle control samples
#' @param viability_positive_control character string: chem_id for viability positive control samples
#' @param study_name character string: name of study to be used for plot titles
#' @param mongoUrl character string: The URL of the mongo database holding the collection, with user credentials to access it
#' @param use_db boolean: Determines whether mongoDB will be used or not; default is TRUE
#' @param json_collection_path character: Full file path to where JSON collections will be stored
#'
#' @import data.table
#' @import plyr
#' @import dplyr
#' @import tidyr
#' @import jsonlite
#' @import mongolite
#' @import stringr
#' @import tictoc
#' @import tibble
#' @import ggplot2
#'
#' @export viability_controlPlot_htppWell
#'
viability_controlPlot_htppWell<-function(file_path, vehicle_control, viability_positive_control, study_name, mongoUrl="", use_db=T, json_collection_path=""){

  if(use_db==T){
    CCData <- data.table(mongo(collection="htpp_well", url=mongoUrl,
                             verbose=getOption("verbose"))$find(query=mongoQuery(chem_id = c(vehicle_control, viability_positive_control)),
                                                                fields=mongoQuery(pg_id=1, plate_id=1, cell_type=1, chem_id=1, sample_id=1, rel_cell_count=1)))
  } else {
    if(file.exists(paste(json_collection_path,"htpp_well.JSON",sep="/"))){
      htpp_well  <-data.table(fromJSON(txt=paste(json_collection_path,"htpp_well.JSON",sep="/")))
      htpp_well[htpp_well == "NA"] <- NA
      CCData <- htpp_well %>% subset(select=c("pg_id", "plate_id", "cell_type", "chem_id", "sample_id", "rel_cell_count")) %>% filter(chem_id %in%c(vehicle_control, viability_positive_control))
    } else {
      stop("htpp_well.JSON not found, check json_collection_path parameter.")
    }
    }
  for(cell in unique(CCData[, cell_type])){
    dat <- CCData[cell_type == cell]
    ggplot(data = dat, aes(x=plate_id, y=rel_cell_count, color=chem_id, shape=chem_id)) +
      geom_jitter(width=0.1, height=0, alpha=0.5) +
      scale_color_manual(values=c("gray50", "red")) +
      theme_bw() +
      ylim(0, NA) +
      ggtitle(paste(study_name, cell, sep = " "), subtitle=paste0("htpp_well: relative cell count\n", Sys.Date())) +
      theme(axis.text.x = element_text(angle=90, hjust=0.5, vjust=0.5))
    ggsave(paste0(file_path, "/", study_name, "_", cell, "_", vehicle_control, "_", viability_positive_control, ".png"), width=5, height=4, units = "in")
  }
}

#' Function to plot normalized well values based on vehicle and viability controls and write the plots to the location specified in file_path
#'
#' @param mongoUrl A string consisting of the databased url and required credentials, generated by the mongoURL function
#' @param file_path A string consisting of the path where the plots will be stored
#' @param vehicle_control A string containing the vehicle chemical (such as dmso) used in this experiment
#' @param viability_positive_control A string containing the viability positive control chemical
#' @param study_name A string containing the name of the study
#' @param use_db boolean: Determines whether mongoDB will be used or not; default is TRUE
#' @param json_collection_path character: Full file path to where JSON collections will be stored
#'
#' @import data.table
#' @import plyr
#' @import dplyr
#' @import tidyr
#' @import jsonlite
#' @import mongolite
#' @import stringr
#' @import tictoc
#' @import tibble
#' @import ggplot2
#'
#' @export viability_controlPlot_htppWellNorm

viability_controlPlot_htppWellNorm <- function(mongoUrl="", file_path, vehicle_control, viability_positive_control, study_name, use_db=T, json_collection_path=""){

  if (use_db==T){
    CCData = data.table(mongo(collection="htpp_well_norm", url=mongoUrl,
                            verbose=getOption("verbose"))$find(query=mongoQuery(chem_id=c(vehicle_control, viability_positive_control)),
                                                               fields=mongoQuery(pg_id=1, plate_id=1, chem_id=1, cell_type = 1, sample_id=1, rel_cell_count=1)))
  } else{
    if(file.exists(paste(json_collection_path,"htpp_well_norm.JSON",sep="/"))){
      htpp_well_norm  <-data.table(fromJSON(txt=paste(json_collection_path,"htpp_well_norm.JSON",sep="/")))
      htpp_well_norm[htpp_well_norm == "NA"] <- NA
      CCData <- htpp_well_norm %>% subset(select=c("pg_id", "plate_id", "cell_type", "chem_id", "sample_id", "rel_cell_count")) %>% filter(chem_id %in%c(vehicle_control, viability_positive_control))
    } else {
      stop("htpp_well_norm.JSON not found, check json_collection_path parameter.")
    }
}
  for(cell in unique(CCData[, cell_type])){
    dat <- CCData[cell_type == cell]
    ggplot(dat, aes(x=pg_id, y=rel_cell_count, color=chem_id, shape=chem_id)) +
      geom_jitter(width=0.2, height=0, alpha=0.5) +
      scale_color_manual(values=c("gray50", "red")) +
      theme_bw() + ylim(0, NA) +
      ggtitle(paste(study_name, cell, sep = " "), subtitle=paste0("htpp_well: relative cell count\n", Sys.Date()))
    ggsave(paste0(file_path, "/", study_name, "_", cell, "_htpp_well_norm_rel_cell_count_", vehicle_control, "_", viability_positive_control,".png"), width=5, height=4, units = "in")
  }
}

#' Plots global mahalanobis distances from htpp_tcpl collection, writes plots of global data to the location specified by file_path
#'
#' @param file_path character: file path to where global mah plots will be created
#' @param study_name character string: name of study to be used for plot titles, should follow a similar naming convention used in other functions such as "viability_controlPlot_htppWell.R"
#' @param mongoUrl haracter string: URL to connect to MongoDB for HTPP dataset; can be created using the mongoURL function in htpp.pl
#' @param use_db boolean: Determines whether mongoDB will be used or not; default is TRUE
#' @param json_collection_path character: Full file path to where JSON collections will be stored
#'
#' @import data.table
#' @import plyr
#' @import dplyr
#' @import tidyr
#' @import jsonlite
#' @import mongolite
#' @import stringr
#' @import tictoc
#' @import tibble
#' @import ggplot2
#'
#'
#' @export curvePlots_htppGlobalMah
#'
curvePlots_htppGlobalMah <- function(file_path, study_name, mongoUrl="", use_db=T, json_collection_path=""){

 if (use_db==T){ htpp_tcpl <- mongo(collection = "htpp_tcpl", url = mongoUrl, verbose = getOption("verbose"))
  htpp_well_trt <- mongo(collection = "htpp_well_trt", url = mongoUrl, verbose = getOption("verbose"))

  if (htpp_tcpl$count(query = mongoQuery(approach = "global", endpoint = "global"))<1){
    stop("The there are no global documents in htpp_tcpl to plot. Please ensure htpp_tcpl is filled correctly before proceeding.")
  }

  for(cell in htpp_well_trt$distinct(key = "cell_type")){

    CPData <- htpp_tcpl$find(query = mongoQuery(cell_type = cell, approach = "global", endpoint = "global"))

    setdiff( c("a", "tp", "b", "ga", "p", "la", "q"), colnames(CPData))

    CPData <- CPData %>% dplyr::mutate(name = chem_id, la = NA, q = NA)

    Subset <- CPData %>% dplyr::mutate(acc = ifelse(is.na(acc), bmd, acc))

    Subset2 <- Subset %>% filter(stype %in% c("test sample") & bmd < 100 & hitcall > 0.90)#172

    for(iRow in 1:dim(Subset2)[1]){
      png(paste0(file_path,"/", study_name, "_", cell, "_", Subset2$pg_id[iRow], "_", Subset2$chem_id[iRow], ".png"), width=800, height=600)
      concRespPlot_JN(row = Subset2[iRow,])
      dev.off()
    }

    #all curves look good

    Subset2 <- Subset %>% filter(stype %in% c("reference chemical"))

    for(iRow in 1:dim(Subset2)[1]){
      png(paste0(file_path,"/", study_name, "_", cell, "_", Subset2$chem_id[iRow], "_", Subset2$pg_id[iRow], ".png"), width=800, height=600)
      concRespPlot_JN(row = Subset2[iRow,])
      dev.off()
    }

    Subset2 <- Subset %>% filter(stype %in% c("null") & bmd < 200 & hitcall > 0.1)

    if(dim(Subset2)[1] > 0){
      for(iRow in 1:dim(Subset2)[1]){
        png(paste0(file_path,"/", cell, "_", Subset2$chem_id[iRow], "_", Subset2$pg_id[iRow], "nullChem.png"), width=800, height=600)
        concRespPlot_JN(row = Subset2[iRow,])
        dev.off()
      }
    } else{
      cat("No null chemicals had BMD < 200 and hitcall > 0.1 for", cell, "cells\n")
    }

    RefChem <- Subset %>% filter(stype %in% c("reference chemical") & chem_id != "TSA") %>% dplyr::mutate(pg_id = as.character(pg_id))

    ggplot(RefChem, aes(x = pg_id)) +
      facet_grid(~chem_id) +
      geom_linerange(aes(ymin = bmd, ymax = bmdl)) +
      geom_linerange(aes(ymin = bmd, ymax = bmdu)) +
      geom_point(aes(y = bmd)) +
      geom_rect(aes(xmin = 0.5, xmax = 1.5, ymin = min_conc, ymax = max_conc), alpha = 0.2, fill = "gray50", color = "transparent") +
      scale_y_log10(breaks = c(10^c(-6:2))) +
      coord_flip() +
      ggtitle(paste(study_name, cell, sep = " "), subtitle="Global Mahalanobis distance") +
      theme_bw()
    ggsave(paste0(file_path, "/",  study_name, "_", cell, "_", "htpp_tcpl_global_Reference_chemicals.png"), width=12, height=6)


    NullChem <- Subset %>% filter(stype %in% c("null")) %>% dplyr::mutate(pg_id = as.character(pg_id)) %>%
      dplyr::mutate(B = ifelse((hitcall > 0.01 & !is.na(bmd) & bmd < max_conc), T, F),
                    BMC = ifelse(bmd > 1000 | is.na(bmd), 1000, bmd))

    cat(table(NullChem$B)[1], "negative null chemicals for", cell, "cells\n")


    ggplot(NullChem, aes(x = BMC, y = stype)) +
      geom_jitter(height = 0.5, width = 0, alpha = 0.5) +
      scale_x_log10(breaks = c(10^c(-6:6))) +
      annotate(geom = "rect", xmin = 10^-1.5, xmax = 10^2, ymin = 0.5, ymax = 1.5, alpha = 0.2, fill = "gray50", color = "transparent") +
      ggtitle(paste(study_name, cell, sep = " "), subtitle="Global Mahalanobis distance") +
      theme_bw()
    ggsave(paste0(file_path,"/",  study_name, "_", cell, "htpp_tcpl_global_Null_chemicals_(1).png"), width=6, height=3)

    ggplot(NullChem, aes(x = BMC, y = hitcall)) +
      geom_point(alpha = 0.5) +
      scale_x_log10(breaks = c(10^c(-6:6))) +
      annotate(geom ="rect", xmin = 10^-1.5, xmax = 10^2, ymin = 0, ymax = 0.1, alpha = 0.2, fill = "gray50", color = "transparent") +
      ggtitle(paste(study_name, cell, sep = " "), subtitle="Global Mahalanobis distance") +
      theme_bw()
    ggsave(paste0(file_path, "/",  study_name, "_", cell, "htpp_tcpl_global_Null_chemicals_(2)_v211014.png"), width=6, height=3)

  } #for each cell type
 } else {
   if(file.exists(paste(json_collection_path,"htpp_tcpl.JSON",sep="/"))){
     htpp_tcpl  <-data.table(fromJSON(txt=paste(json_collection_path,"htpp_tcpl.JSON",sep="/")))
     htpp_tcpl[htpp_tcpl == "NA"] <- NA
   } else {
     message("htpp_tcpl.JSON not found, check json_collection_path parameter.")
   }

   if(file.exists(paste(json_collection_path,"htpp_well_trt.JSON",sep="/"))){
     htpp_well_trt  <-data.table(fromJSON(txt=paste(json_collection_path,"htpp_well_trt.JSON",sep="/")))
     htpp_well_trt[htpp_well_trt == "NA"] <- NA
   } else {
     message("htpp_well_trt.JSON not found, check json_collection_path parameter.")
   }

   if (nrow(htpp_tcpl[approach=="global" & endpoint=="global"])<1){
     stop("The there are no global documents in htpp_tcpl to plot. Please ensure htpp_tcpl is filled correctly before proceeding.")
   }

   for(cell in unique(htpp_well_trt[, cell_type])){

     CPData <- htpp_tcpl[cell_type == cell & approach == "global" & endpoint == "global"]

     setdiff( c("a", "tp", "b", "ga", "p", "la", "q"), colnames(CPData))

     CPData <- CPData %>% dplyr::mutate(name = chem_id, la = NA, q = NA)

     Subset <- CPData %>% dplyr::mutate(acc = ifelse(is.na(acc), bmd, acc))

     Subset <- as.data.frame(Subset)

     Subset2 <- Subset %>% filter(stype %in% c("test sample") & bmd < 100 & hitcall > 0.90)#172

     for(iRow in 1:dim(Subset2)[1]){
       png(paste0(file_path,"/", study_name, "_", cell, "_", Subset2$pg_id[iRow], "_", Subset2$chem_id[iRow], ".png"), width=800, height=600)
       concRespPlot_JN(row = Subset2[iRow,])
       dev.off()
     }

     #all curves look good

     Subset2 <- Subset %>% filter(stype %in% c("reference chemical"))

     for(iRow in 1:dim(Subset2)[1]){
       png(paste0(file_path,"/", study_name, "_", cell, "_", Subset2$chem_id[iRow], "_", Subset2$pg_id[iRow], ".png"), width=800, height=600)
       concRespPlot_JN(row = Subset2[iRow,])
       dev.off()
     }

     Subset2 <- Subset %>% filter(stype %in% c("null") & bmd < 200 & hitcall > 0.1)

     if(dim(Subset2)[1] > 0){
       for(iRow in 1:dim(Subset2)[1]){
         png(paste0(file_path,"/", cell, "_", Subset2$chem_id[iRow], "_", Subset2$pg_id[iRow], "nullChem.png"), width=800, height=600)
         concRespPlot_JN(row = Subset2[iRow,])
         dev.off()
       }
     } else{
       cat("No null chemicals had BMD < 200 and hitcall > 0.1 for", cell, "cells\n")
     }

     RefChem <- Subset %>% filter(stype %in% c("reference chemical") & chem_id != "TSA") %>% dplyr::mutate(pg_id = as.character(pg_id))

     ggplot(RefChem, aes(x = pg_id))+
       facet_grid(~chem_id) +
       geom_linerange(aes(ymin = bmd, ymax = bmdl)) +
       geom_linerange(aes(ymin = bmd, ymax = bmdu)) +
       geom_point(aes(y = bmd)) +
       geom_rect(aes(xmin = pg_id - 0.3, xmax = pg_id + 0.3, ymin = min_conc, ymax = max_conc), alpha = 0.2, fill = "gray50", color = "transparent") +
       scale_y_log10(breaks = c(10^c(-6:2))) +
       coord_flip() +
       ggtitle(paste(study_name, cell, sep = " "), subtitle="Global Mahalanobis distance") +
       theme_bw()
     ggsave(paste0(file_path, "/",  study_name, "_", cell, "_", "htpp_tcpl_global_Reference_chemicals.png"), width=12, height=6)


     NullChem <- Subset %>% filter(stype %in% c("null")) %>% dplyr::mutate(pg_id = as.character(pg_id)) %>%
       dplyr::mutate(B = ifelse((hitcall > 0.01 & !is.na(bmd) & bmd < max_conc), T, F),
                     BMC = ifelse(bmd > 1000 | is.na(bmd), 1000, bmd))

     cat(table(NullChem$B)[1], "negative null chemicals for", cell, "cells\n")


     ggplot(NullChem, aes(x = BMC, y = stype)) +
       geom_jitter(height = 0.5, width = 0, alpha = 0.5) +
       scale_x_log10(breaks = c(10^c(-6:6))) +
       annotate(geom = "rect", xmin = 10^-1.5, xmax = 10^2, ymin = 0.5, ymax = 1.5, alpha = 0.2, fill = "gray50", color = "transparent") +
       ggtitle(paste(study_name, cell, sep = " "), subtitle="Global Mahalanobis distance") +
       theme_bw()
     ggsave(paste0(file_path,"/",  study_name, "_", cell, "htpp_tcpl_global_Null_chemicals_(1).png"), width=6, height=3)

     ggplot(NullChem, aes(x = BMC, y = hitcall)) +
       geom_point(alpha = 0.5) +
       scale_x_log10(breaks = c(10^c(-6:6))) +
       annotate(geom ="rect", xmin = 10^-1.5, xmax = 10^2, ymin = 0, ymax = 0.1, alpha = 0.2, fill = "gray50", color = "transparent") +
       ggtitle(paste(study_name, cell, sep = " "), subtitle="Global Mahalanobis distance") +
       theme_bw()
     ggsave(paste0(file_path, "/",  study_name, "_", cell, "htpp_tcpl_global_Null_chemicals_(2)_v211014.png"), width=6, height=3)

} #for each cell type
 }
  }


#' plot category Mahalanobis distances and save the plots to the location specified by file_path.
#'
#' @param file_path character: file path to where category mah plots will be created
#' @param study_name character string: name of study to be used for plot titles, should follow a similar naming convention used in other functions such as "viability_controlPlot_htppWell.R"
#' @param mongoUrl character string: URL to connect to MongoDB for HTPP dataset; can be created using the mongoURL function in htpp.pl
#' @param use_db boolean: Determines whether mongoDB will be used or not; default is TRUE
#' @param json_collection_path character: Full file path to where JSON collections will be stored
#'
#' @import data.table
#' @import plyr
#' @import dplyr
#' @import tidyr
#' @import jsonlite
#' @import mongolite
#' @import stringr
#' @import tictoc
#' @import tibble
#' @import ggplot2
#'
#'
#' @return a summary table for debugging
#'
#' @export curvePlots_htppCatMah
#'
curvePlots_htppCatMah <- function(file_path, study_name, mongoUrl="", use_db=T, json_collection_path=""){
if (use_db==T){
  htpp_tcpl <- mongo(collection = "htpp_tcpl", url = mongoUrl, verbose = getOption("verbose"))
  if(htpp_tcpl$count(query = mongoQuery(approach = "category"))<1){
    stop("The htpp_tcpl collection has no category records to plot. Please ensure those records were input correctly before proceeding.")
  }

  htpp_well_trt <- mongo(collection = "htpp_well_trt", url = mongoUrl, verbose = getOption("verbose"))

  for(cell in htpp_well_trt$distinct(key = "cell_type")){

    CPData <- htpp_tcpl$find(query = mongoQuery(cell_type = cell, approach = "category"))

    setdiff(c("a", "tp", "b", "ga", "p", "la", "q"), colnames(CPData))

    CPData <- CPData %>% dplyr::mutate(name = chem_id, la = NA, q = NA, dtxsid = chem_id)

    RefChem <- CPData %>% filter(stype %in% c("reference chemical")) %>% dplyr::mutate(pg_id = as.character(pg_id)) %>%
      filter(hitcall  >0.5) %>%
      group_by(pg_id, chem_id) %>% dplyr::mutate(RankTop = rank(-top_over_cutoff, ties.method = "min"),
                                                 RankBMC = rank(bmd, ties.method="min")) %>%
      filter(RankTop <= 5 | RankBMC <= 5)

    message(paste0(capture.output(table(RefChem$endpoint, RefChem$chem_id)), collapse = "\n"))

    NullChem <- CPData %>% filter(stype %in% c("null")) %>% dplyr::mutate(pg_id = as.character(pg_id)) %>%
      dplyr::mutate(B = (hitcall > 0.5 & bmd < max_conc)) %>% filter(B)

    ggplot(NullChem, aes(x = acc, y = top_over_cutoff, color = fit_method)) +
      geom_point(alpha = 0.5) +
      scale_x_log10() +
      ylim(0, NA) +
      ggtitle(paste(study_name, cell, sep = " "), subtitle = "Category-level Mahalanobis distance\nNull chemicals: individual curves")
    ggsave(paste0(file_path, "/",  study_name, "_", cell, "_", "htpp_tcpl_category_Null_chemicals_1.png"), width = 8, height = 8)

    ggplot(NullChem, aes(x = acc, y = hitcall, color = fit_method)) +
      geom_point(alpha = 0.5) +
      scale_x_log10() +
      ggtitle(paste(study_name, cell, sep = " "), subtitle = "Category-level Mahalanobis distance\nNull chemicals: individual curves")
    ggsave(paste0(file_path,"/",  study_name, "_", cell, "htpp_tcpl_category_Null_chemicals_2.png"), width = 8, height = 8)


    ZF_Null <- CPData %>% filter(stype %in% c("null")) %>% dplyr::mutate(pg_id = as.character(pg_id)) %>%
      dplyr::mutate(B = (hitcall > 0.95 & bmd < max_conc))%>%
      dplyr::group_by(pg_id, chem_id) %>% dplyr::summarise(sumB = sum(B))

    message(paste0(capture.output(table(ZF_Null$sumB > 0)), collapse = "\n"))

    ZF <- CPData %>% dplyr::mutate(pg_id = as.character(pg_id)) %>%
      dplyr::mutate(B = (hitcall > 0.9 & bmd < max_conc))%>%
      dplyr::group_by(pg_id, stype, chem_id) %>% dplyr::summarise(sumB = sum(B))

    return(base::table(ZF$stype, ZF$sumB>0))

  } #for each cell type
} else {

  if(file.exists(paste(json_collection_path,"htpp_tcpl.JSON",sep="/"))){
      htpp_tcpl  <-data.table(fromJSON(txt=paste(json_collection_path,"htpp_tcpl.JSON",sep="/")))
      htpp_tcpl[htpp_tcpl == "NA"] <- NA
    } else {
      message("htpp_tcpl.JSON not found, check json_collection_path parameter.")
    }

    if(file.exists(paste(json_collection_path,"htpp_well_trt.JSON",sep="/"))){
      htpp_well_trt <- data.table(fromJSON(txt=paste(json_collection_path,"htpp_well_trt.JSON",sep="/")))
      htpp_well_trt[htpp_well_trt == "NA"] <- NA
    } else {
      stop("htpp_well_trt.JSON not found, check json_collection_path parameter.")
    }

    if (nrow(htpp_tcpl[approach=="category"])<1){
      stop("The there are no category records in htpp_tcpl to plot. Please ensure htpp_tcpl is filled correctly before proceeding.")
    }

    for(cell in unique(htpp_well_trt[, cell_type])){

      CPData <- htpp_tcpl[cell_type == cell & approach == "category"]

      CPData <- as.data.frame(CPData)

      setdiff(c("a", "tp", "b", "ga", "p", "la", "q"), colnames(CPData))

      CPData <- CPData %>% dplyr::mutate(name = chem_id, la = NA, q = NA, dtxsid = chem_id)

      RefChem <- CPData %>% filter(stype %in% c("reference chemical")) %>% dplyr::mutate(pg_id = as.character(pg_id)) %>%
        filter(hitcall  >0.5) %>%
        group_by(pg_id, chem_id) %>% dplyr::mutate(RankTop = rank(-top_over_cutoff, ties.method = "min"),
                                                   RankBMC = rank(bmd, ties.method="min")) %>%
        filter(RankTop <= 5 | RankBMC <= 5)

      message(paste0(capture.output(table(RefChem$endpoint, RefChem$chem_id)), collapse = "\n"))

      NullChem <- CPData %>% filter(stype %in% c("null")) %>% dplyr::mutate(pg_id = as.character(pg_id)) %>%
        dplyr::mutate(B = (hitcall > 0.5 & bmd < max_conc)) %>% filter(B)

      ggplot(NullChem, aes(x = acc, y = top_over_cutoff, color = fit_method)) +
        geom_point(alpha = 0.5) +
        scale_x_log10() +
        ylim(0, NA) +
        ggtitle(paste(study_name, cell, sep = " "), subtitle = "Category-level Mahalanobis distance\nNull chemicals: individual curves")
      ggsave(paste0(file_path, "/",  study_name, "_", cell, "_", "htpp_tcpl_category_Null_chemicals_1.png"), width = 8, height = 8)

      ggplot(NullChem, aes(x = acc, y = hitcall, color = fit_method)) +
        geom_point(alpha = 0.5) +
        scale_x_log10() +
        ggtitle(paste(study_name, cell, sep = " "), subtitle = "Category-level Mahalanobis distance\nNull chemicals: individual curves")
      ggsave(paste0(file_path,"/",  study_name, "_", cell, "htpp_tcpl_category_Null_chemicals_2.png"), width = 8, height = 8)


      ZF_Null <- CPData %>% filter(stype %in% c("null")) %>% dplyr::mutate(pg_id = as.character(pg_id)) %>%
        dplyr::mutate(B = (hitcall > 0.95 & bmd < max_conc))%>%
        dplyr::group_by(pg_id, chem_id) %>% dplyr::summarise(sumB = sum(B))

      message(paste0(capture.output(table(ZF_Null$sumB > 0)), collapse = "\n"))

      ZF <- CPData %>% dplyr::mutate(pg_id = as.character(pg_id)) %>%
        dplyr::mutate(B = (hitcall > 0.9 & bmd < max_conc))%>%
        dplyr::group_by(pg_id, stype, chem_id) %>% dplyr::summarise(sumB = sum(B))

      return(base::table(ZF$stype, ZF$sumB>0))

    } #for each cell type
  }
}

#' Feature plotting function, writes plots of feature-level data to the location specified by file_path
#'
#' @param file_path character: file path to where global mah plots will be created
#' @param study_name character string: name of study to be used for plot titles, should follow a similar naming convention used in other functions such as "viability_controlPlot_htppWell.R"
#' @param mongoUrl character string: URL to connect to MongoDB for HTPP dataset; can be created using the mongoURL function in htpp.pl
#' @param use_db boolean: Determines whether mongoDB will be used or not; default is TRUE
#' @param json_collection_path character: Full file path to where JSON collections will be stored
#'
#' @import data.table
#' @import plyr
#' @import dplyr
#' @import tidyr
#' @import jsonlite
#' @import mongolite
#' @import stringr
#' @import tictoc
#' @import tibble
#' @import ggplot2
#' @import rlist
#'
#'
#' @export curvePlots_htppFeature
#'
curvePlots_htppFeature <- function(file_path, study_name, mongoUrl="", use_db=T, json_collection_path="") {
if(use_db==T){
  htpp_tcpl <- mongo(collection = "htpp_tcpl", url = mongoUrl, verbose = getOption("verbose"))
  if (htpp_tcpl$count(query = mongoQuery(approach = "feature"))<1){
    stop("The there are no feature documents in htpp_tcpl to plot. Please ensure htpp_tcpl is filled correctly before proceeding.")
  }

  htpp_well_trt <- mongo(collection = "htpp_well_trt", url = mongoUrl, verbose = getOption("verbose"))

  chemList <- htpp_tcpl$distinct(key = "chem_id", query = mongoQuery(approach = "feature", stype = "reference chemical")) %>%
    list.filter(. %in% htpp_well_trt$find(query = mongoQuery(dose_level = 8))$chem_id)


  for(cell in htpp_well_trt$distinct(key = "cell_type")){
    CPData <- htpp_tcpl$find(query = mongoQuery(approach = "feature", stype = "reference chemical", cell_type = cell))

    FeatureList <- mongo(collection = "htpp_feature", url = mongoUrl, verbose = getOption("verbose"))$find()
    FeatureList <- FeatureList %>% filter(!is.na(feature_id)) %>% select(feature_name_r, feature_name_mongo)

    RefChem <- CPData %>% filter(stype %in% c("reference chemical") & chem_id != "TSA") %>%
      left_join(FeatureList, by = c("endpoint"="feature_name_mongo")) %>%
      dplyr::mutate(pg_id = as.character(pg_id),
                    BMC = ifelse(hitcall > 0.5 & !is.na(bmd) & bmd < max_conc, bmd, max_conc*3),
                    BMC = ifelse(BMC < min_conc/3, min_conc/3, BMC),
                    EffectSize = top_over_cutoff*sign(top),
                    EffectSize = ifelse(is.na(EffectSize), 0, EffectSize),
                    EffectSize = ifelse(abs(EffectSize) > 30, 30*sign(EffectSize), EffectSize)) %>%
      group_by(pg_id, chem_id) %>% dplyr::mutate(RankTop = rank(-abs(EffectSize), ties.method = "min"),
                                                 RankBMC = rank(BMC, ties.method = "min")) %>%
      arrange(desc(RankTop))

    for(Chem in chemList){

      print(Chem)

      Subset <- RefChem %>% filter(chem_id == Chem)

      DoseRange <- Subset %>% select(chem_id, pg_id, cell_type, min_conc, max_conc) %>% distinct() %>% dplyr::mutate(BMC = 1, EffectSize = 1)

      ggplot(Subset, aes(x = BMC, y = EffectSize)) +
        #facet_wrap(~pg_id, nrow=4) +
        geom_point(color = ColumnColors(Subset$feature_name_r,"vector"), shape = PchShape(Subset$feature_name_r), size = 2.5, alpha = 0.7) +
        geom_text(data = Subset, aes(label = ifelse(RankTop < 50 | RankBMC < 50, GOLetter(feature_name_r), "")), size = 2.5) +
        geom_rect(data = DoseRange, aes(xmin = min_conc, xmax = max_conc, ymin = -1, ymax = 1), fill = "gray50", color = "transparent", alpha = 0.3) +
        scale_x_log10(breaks = c(10^c(-6:2))) +
        ggtitle(paste(study_name, cell, Chem, sep = " "), subtitle="Feature-level fitting") +
        xlab("BMC") +
        theme_bw()
      ggsave(paste0(file_path, "/", study_name, "_", "htpp_tcpl_feature_level_RefChem", cell, "_", Chem, ".png"), width = 14, height = 8)

    } #for each ref chem
  }#for each cell type
}else{
  if(file.exists(paste(json_collection_path,"htpp_tcpl.JSON",sep="/"))){
    htpp_tcpl  <-data.table(fromJSON(txt=paste(json_collection_path,"htpp_tcpl.JSON",sep="/")))
    htpp_tcpl[htpp_tcpl == "NA"] <- NA
  } else {
    message("htpp_tcpl.JSON not found, check json_collection_path parameter.")
  }

  if(file.exists(paste(json_collection_path,"htpp_well_trt.JSON",sep="/"))){
    htpp_well_trt  <-data.table(fromJSON(txt=paste(json_collection_path,"htpp_well_trt.JSON",sep="/")))
    htpp_well_trt[htpp_well_trt == "NA"] <- NA
  } else {
    message("htpp_well_trt.JSON not found, check json_collection_path parameter.")
  }

  if (nrow(htpp_tcpl[approach=="feature"])<1){
    stop("The there are no feature-level records in htpp_tcpl to plot. Please ensure htpp_tcpl is filled correctly before proceeding.")
  }

  if(file.exists(paste(json_collection_path,"htpp_feature.JSON",sep="/"))){
    htpp_feature  <-data.table(fromJSON(txt=paste(json_collection_path,"htpp_feature.JSON",sep="/")))
    htpp_feature[htpp_feature == "NA"] <- NA
  } else {
    message("htpp_feature.JSON not found, check json_collection_path parameter.")
  }
  chemList<- htpp_tcpl[approach=="feature" & stype=="reference chemical"]
  chemList <- chemList[chem_id %in% unique(htpp_well_trt[dose_level == 8, chem_id])]
  chemList <- unique(chemList[, chem_id])

    for(cell in unique(htpp_well_trt[, cell_type])){
      CPData <- htpp_tcpl[approach == "feature" & stype == "reference chemical" & cell_type == cell]

      FeatureList <- htpp_feature %>% filter(!is.na(feature_id)) %>% select(feature_name_r, feature_name_mongo)

      RefChem <- CPData %>% filter(stype %in% c("reference chemical") & chem_id != "TSA") %>%
        left_join(FeatureList, by = c("endpoint"="feature_name_mongo")) %>%
        dplyr::mutate(pg_id = as.character(pg_id),
                      BMC = ifelse(hitcall > 0.5 & !is.na(bmd) & bmd < max_conc, bmd, max_conc*3),
                      BMC = ifelse(BMC < min_conc/3, min_conc/3, BMC),
                      EffectSize = top_over_cutoff*sign(top),
                      EffectSize = ifelse(is.na(EffectSize), 0, EffectSize),
                      EffectSize = ifelse(abs(EffectSize) > 30, 30*sign(EffectSize), EffectSize)) %>%
        group_by(pg_id, chem_id) %>% dplyr::mutate(RankTop = rank(-abs(EffectSize), ties.method = "min"),
                                                   RankBMC = rank(BMC, ties.method = "min")) %>%
        arrange(desc(RankTop))

      for(Chem in chemList){

        print(Chem)

        Subset <- RefChem %>% filter(chem_id == Chem)

        Subset <- as.data.frame(Subset)

        DoseRange <- Subset %>% select(chem_id, pg_id, cell_type, min_conc, max_conc) %>% distinct() %>% dplyr::mutate(BMC = 1, EffectSize = 1)

        ggplot(Subset, aes(x = BMC, y = EffectSize)) +
          #facet_wrap(~pg_id, nrow=4) +
          geom_point(color = ColumnColors(Subset$feature_name_r,"vector"), shape = PchShape(Subset$feature_name_r), size = 2.5, alpha = 0.7) +
          geom_text(data = Subset, aes(label = ifelse(RankTop < 50 | RankBMC < 50, GOLetter(feature_name_r), "")), size = 2.5) +
          geom_rect(data = DoseRange, aes(xmin = min_conc, xmax = max_conc, ymin = -1, ymax = 1), fill = "gray50", color = "transparent", alpha = 0.3) +
          scale_x_log10(breaks = c(10^c(-6:2))) +
          ggtitle(paste(study_name, cell, Chem, sep = " "), subtitle="Feature-level fitting") +
          xlab("BMC") +
          theme_bw()
        ggsave(paste0(file_path, "/", study_name, "_", "htpp_tcpl_feature_level_RefChem", cell, "_", Chem, ".png"), width = 14, height = 8)

      } #for each ref chem
    }#for each cell type
  } #DB_true/false fork
} #end of function

#' plot pseudo-biomarker concentration and write the plots to the location specified in file_path
#'
#' @param file_path character: file path to where global mah plots will be created
#' @param study_name character string: name of study to be used for plot titles, should follow a similar naming convention used in other functions such as "viability_controlPlot_htppWell.R"
#' @param mongoUrl character string: URL to connect to MongoDB for HTPP dataset; can be created using the mongoURL function in htpp.pl
#' @param bmc_min numeric: Defines the denominator for calculating the minimum bmc value for cases where the bmc is less that the lowest tested conc (i.e., minimum tested conc/bmc_min); default is 10^0.5
#' @param use_db boolean: Determines whether mongoDB will be used or not; default is TRUE
#' @param json_collection_path character: Full file path to where JSON collections will be stored
#'
#' @import data.table
#' @import plyr
#' @import dplyr
#' @import tidyr
#' @import jsonlite
#' @import mongolite
#' @import stringr
#' @import tictoc
#' @import tibble
#' @import ggplot2
#'
#' @export pseudoBmcPlots_htppCatMah
pseudoBmcPlots_htppCatMah <- function(file_path, study_name, mongoUrl, bmc_min=10^0.5, use_db=T, json_collection_path=""){

  htpp_bmc <- mongo(collection = "htpp_bmc", url = mongoUrl, verbose = getOption("verbose"))
  if (use_db==T){
    if(htpp_bmc$count(query=mongoQuery(approach = "category")) <1 ){
    stop("The htpp_bmc collection has no category documents to plot. Please ensure htpp_bmc is created correctly before proceeding.")
  }
  CPData <- data.table(htpp_bmc$find(query = mongoQuery(approach = "category")))

  } else {
    if(file.exists(paste(json_collection_path,"htpp_bmc.JSON",sep="/"))){
      htpp_bmc <-data.table(fromJSON(txt=paste(json_collection_path,"htpp_bmc.JSON",sep="/")))
      htpp_bmc[htpp_bmc == "NA"] <- NA
    } else {
      stop("htpp_bmc.JSON not found, check json_collection_path parameter.")
    }

    if (nrow(htpp_bmc[approach=="category"])<1){
      stop("The there are no category records in htpp_bmc to plot. Please ensure htpp_bmc is filled correctly before proceeding.")
    }

    CPData<-htpp_bmc[approach=="category"]
  }

  RefChem <- CPData %>% filter(stype == "reference chemical" & !is.na(bmc))

  for(cell in unique(CPData[, cell_type])){

    Subset_cell <- CPData[cell_type == cell, ]

    for(Chem in unique(RefChem$chem_id)){

      Subset <- Subset_cell %>% filter(chem_id == Chem) %>%
        dplyr::mutate(bmc = ifelse(is.na(bmc), max_conc*bmc_min, bmc))

      Subset <- as.data.frame(Subset)

      DoseRange <- Subset %>% select(chem_id, cell_type, pg_id, min_conc, max_conc) %>% distinct() %>% dplyr::mutate(bmc = 1, top_over_cutoff = 1)

      Subset$pg_label <- paste0("Plate_group_", Subset$pg_id)
      ggplot(Subset, aes(x = bmc, y = top_over_cutoff)) +
        facet_wrap(~pg_label, nrow = 4) +
        geom_point(shape = PchShape(Subset$endpoint), size = 3, alpha = 0.7, aes(colour = factor(endpoint))) +
        geom_text(label = GOLetter(Subset$endpoint), size = 3) +
        geom_rect(data = DoseRange, aes(xmin = min_conc, xmax = max_conc, ymin = 0, ymax = 1)) +
        scale_x_log10(breaks = c(10^c(-6:2))) +
        labs(colour="endpoint", shape="endpoint")+
        ggtitle(paste(study_name, cell, Chem, sep = " "), subtitle = "Category-level Mahalanobis distance") +
        xlab("BMC") +
        theme_bw()
      ggsave(paste0(file_path, "/", study_name, "_", cell,  "_htpp_bmc_category_RefChem_", Chem, ".png"), width = 14, height = 8)

    } #for each ref chem

  } #for each cell type

}

#' Plot PACs from global mahalanobis
#'
#' @param file_path character: file path to where global mah plots will be created
#' @param study_name haracter string: name of study to be used for plot titles, should follow a similar naming convention used in other functions such as "viability_controlPlot_htppWell.R"
#' @param mongoUrl character string: URL to connect to MongoDB for HTPP dataset; can be created using the mongoURL function in htpp.pl
#' @param use_db boolean: Determines whether mongoDB will be used or not; default is TRUE
#' @param json_collection_path character: Full file path to where JSON collections will be stored
#'
#' @import data.table
#' @import plyr
#' @import dplyr
#' @import tidyr
#' @import jsonlite
#' @import mongolite
#' @import stringr
#' @import tictoc
#' @import tibble
#' @import ggplot2
#'
#' @export pacPlots_htppGlobalMah
#'
pacPlots_htppGlobalMah <- function(file_path, study_name, mongoUrl, use_db=T, json_collection_path=""){

 if(use_db==T){
   htpp_pac<-mongo(collection = "htpp_pac", url = mongoUrl, verbose = getOption("verbose"))
   PAC <- htpp_pac$find(query = mongoQuery(approach = "global"))
 } else {
   if(file.exists(paste(json_collection_path,"htpp_pac.JSON",sep="/"))){
     htpp_pac<-data.table(fromJSON(txt=paste(json_collection_path,"htpp_pac.JSON",sep="/")))
     htpp_pac[htpp_pac == "NA"] <- NA
   } else {
     stop("htpp_pac.JSON not found, check json_collection_path parameter.")
   }

   PAC<-htpp_pac[approach=="global"]
  }

  if (length(PAC)<1){
    stop("The there are no global documents in htpp_pac to plot.  Please ensure htpp_pac is filled correctly before proceeding.")
  }

  lvls <- unique(PAC$stype)
  lvls<-append(lvls, unique(PAC$chem_id))

  Data <- PAC %>% filter(stype != "viability positive control" & chem_id != "TSA") %>%
    dplyr::mutate(Label = ifelse(stype == "reference chemical", chem_id, stype),
                  Label = factor(Label, levels = lvls)) %>% data.table()

  ZF <- Data %>% dplyr::group_by(stype, cell_type) %>% dplyr::summarise(n = sum(hit),
                                                                        N = length(hit))

  message(paste0(capture.output(table(Data$Label, Data$hit, useNA="ifany")), collapse = "\n"))


  ggplot(Data, aes(x = pac, y = stype)) +
    facet_wrap(~cell_type, ncol = 2) +
    geom_jitter(aes(shape = cp_flag, color = Label, alpha = stype), height = 0.2, width = 0, size = 3) +
    scale_shape_manual(values = c(19, 13)) +
    scale_alpha_manual(values = c(0.8, 0.8, 0.5), guide = "none") +
    geom_text(data = ZF, aes(x = 2.5, y = stype, label = paste(n, "/", N)), hjust = 0.5, size = 3) + xlim(NA, 3) +
    xlab("PAC [log10 uM]") + ylab("") +
    ggtitle(study_name, subtitle="Global Mahalanobis distance") +
    theme_bw()
  ggsave(paste0(file_path, "/", study_name, "_htpp_pac_global_PAC",  ".png"), width=8, height=4)
}


#' Create plots from htpp PAC collection category documents
#'
#' @param file_path character: file path to where global mah plots will be created
#' @param study_name character string: name of study to be used for plot titles, should follow a similar naming convention used in other functions such as "viability_controlPlot_htppWell.R"
#' @param mongoUrl character string: URL to connect to MongoDB for HTPP dataset; can be created using the mongoURL function in htpp.pl
#' @param use_db boolean: Determines whether mongoDB will be used or not; default is TRUE
#' @param json_collection_path character: Full file path to where JSON collections will be stored
#'
#' @import data.table
#' @import plyr
#' @import dplyr
#' @import tidyr
#' @import jsonlite
#' @import mongolite
#' @import stringr
#' @import tictoc
#' @import tibble
#' @import ggplot2
#'
#' @export pacPlots_htppCatMah
#'
pacPlots_htppCatMah <- function(file_path, study_name, mongoUrl="", use_db=T, json_collection_path=""){
  if(use_db==T){
    htpp_pac<-mongo(collection = "htpp_pac", url = mongoUrl, verbose = getOption("verbose"))
    PAC <- htpp_pac$find(query = mongoQuery(approach = "category")) %>% data.frame()
  } else {
    if(file.exists(paste(json_collection_path,"htpp_pac.JSON",sep="/"))){
      htpp_pac<-data.table(fromJSON(txt=paste(json_collection_path,"htpp_pac.JSON",sep="/")))
      htpp_pac[htpp_pac == "NA"] <- NA
    } else {
      stop("htpp_pac.JSON not found, check json_collection_path parameter.")
    }
    PAC<-htpp_pac[approach=="category"]
  }

  if (length(PAC)<1){
    stop("The there are no category documents in htpp_pac to plot.  Please ensure htpp_pac is filled correctly before proceeding.")
  }


  Data <- PAC %>% dplyr::filter(stype != "viability positive control" & chem_id != "TSA") %>%
    dplyr::mutate(Label = ifelse(stype == 'reference chemical', chem_id, stype),
                  Label = factor(Label))

  ZF <- Data %>% dplyr::group_by(stype) %>% dplyr::summarise(n = sum(hit), N = length(hit))

  message(paste0(capture.output(table(Data$Label, Data$hit)), collapse = "\n"))

  ggplot(Data, aes(x = pac, y = stype)) +
    facet_wrap(~cell_type, ncol = 2) +
    geom_jitter(aes(shape = cp_flag, color = Label, alpha = stype), height = 0.2, width = 0, size = 1.5) +
    scale_shape_manual(values = c(19, 13)) +
    scale_alpha_manual(values = c(0.8, 0.8, 0.5), guide = "none") +
    geom_text(data = ZF, aes(x = 2.5, y = stype, label = paste(n, "/", N)), hjust = 0.5, size = 3) + xlim(NA, 3) +
    xlab("PAC [log10 uM]") +
    ylab("") +
    ggtitle(study_name, subtitle="Category Mahalanobis distance") +
    theme_bw()
  ggsave(paste0(file_path, "/", study_name, "_htpp_pac_category_PAC.png"), width=8, height=4)
}
